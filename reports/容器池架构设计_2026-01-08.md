# 容器池架构设计文档

## 文档信息
- **项目**: HelloAgents 学习平台
- **模块**: 代码执行沙箱优化
- **版本**: v1.0
- **日期**: 2026-01-08
- **作者**: Technical Architect
- **状态**: 设计完成

---

## 1. 架构概述

### 1.1 背景与问题
当前沙箱实现 (`backend/app/sandbox.py`) 采用 **一次性容器模式**:
- 每次代码执行创建新容器
- 执行完成后立即销毁容器
- 容器启动开销: 1-2秒
- 在高并发场景下性能瓶颈明显

### 1.2 解决方案
引入 **容器池架构** 实现容器复用:
- 预创建容器池减少启动延迟
- 容器执行后重置而非销毁
- 动态扩缩容应对负载变化
- 健康检查保证容器可用性

### 1.3 性能提升目标
| 指标 | 当前 | 目标 | 提升 |
|------|------|------|------|
| 首次执行延迟 | 1-2s | 0.05-0.1s | 10-20倍 |
| 连续执行延迟 | 1-2s | 0.05-0.1s | 10-20倍 |
| 并发处理能力 | 低 | 高 (最多10容器) | 10倍 |
| 资源利用率 | 低 | 高 | 5-10倍 |

---

## 2. 核心组件设计

### 2.1 ContainerPool 类结构

```python
class ContainerPool:
    """
    容器池管理器

    职责:
    - 容器生命周期管理 (创建/复用/销毁)
    - 容器健康检查与自动恢复
    - 并发控制与资源限制
    - 容器重置与状态清理
    """

    def __init__(
        self,
        initial_size: int = 3,      # 初始容器数
        max_size: int = 10,         # 最大容器数
        min_size: int = 1,          # 最小容器数
        idle_timeout: int = 300,    # 空闲超时 (5分钟)
        health_check_interval: int = 30,  # 健康检查间隔 (30秒)
        image: str = "python:3.11-slim",
        **container_config         # 容器配置参数
    ):
        """初始化容器池"""

        # 配置参数
        self.initial_size = initial_size
        self.max_size = max_size
        self.min_size = min_size
        self.idle_timeout = idle_timeout
        self.health_check_interval = health_check_interval
        self.image = image
        self.container_config = container_config

        # Docker 客户端
        self.client = docker.from_env()

        # 容器管理
        self.available_containers = Queue(maxsize=max_size)  # 可用容器队列
        self.in_use_containers = {}     # 使用中的容器 {container_id: metadata}
        self.container_metadata = {}    # 容器元数据 {container_id: ContainerMetadata}

        # 线程安全锁
        self.lock = threading.RLock()   # 用于保护共享状态

        # 统计信息
        self.stats = {
            'total_created': 0,         # 总创建数
            'total_destroyed': 0,       # 总销毁数
            'total_executions': 0,      # 总执行次数
            'total_resets': 0,          # 总重置次数
            'health_check_failures': 0, # 健康检查失败次数
        }

        # 后台线程
        self.health_check_thread = None
        self.idle_cleanup_thread = None
        self.running = False

        # 初始化池
        self._initialize_pool()
```

### 2.2 ContainerMetadata 数据结构

```python
@dataclass
class ContainerMetadata:
    """容器元数据"""
    container_id: str           # 容器 ID
    container: docker.Container # Docker 容器对象
    created_at: float           # 创建时间戳
    last_used_at: float         # 最后使用时间
    execution_count: int        # 执行次数
    reset_count: int            # 重置次数
    status: str                 # 状态: 'available', 'in_use', 'unhealthy'
    health_check_failures: int  # 连续健康检查失败次数
```

### 2.3 核心方法

#### 2.3.1 容器获取
```python
def get_container(self, timeout: int = 30) -> Optional[docker.Container]:
    """
    从池中获取可用容器

    逻辑:
    1. 尝试从队列获取现有容器 (非阻塞)
    2. 如果队列为空且未达上限，创建新容器
    3. 如果达到上限，阻塞等待可用容器 (最多 timeout 秒)
    4. 更新容器状态为 'in_use'
    5. 记录使用时间戳

    返回:
        容器对象或 None (超时)
    """
    pass
```

#### 2.3.2 容器归还
```python
def return_container(self, container: docker.Container) -> None:
    """
    归还容器到池中

    逻辑:
    1. 停止容器中运行的进程 (docker stop)
    2. 执行容器重置
    3. 健康检查
    4. 如果健康，归还到可用队列
    5. 如果不健康，销毁并创建新容器 (保持池大小)
    6. 更新容器元数据
    """
    pass
```

#### 2.3.3 容器创建
```python
def _create_container(self) -> docker.Container:
    """
    创建新容器

    配置:
    - 内存限制: 128MB
    - CPU 限制: 50% (半核)
    - 进程数限制: 64
    - 网络: 禁用
    - 文件系统: 只读 + 10MB tmpfs
    - 安全: 移除所有 capabilities
    - 模式: 长期运行 (detach=True)
    - 命令: sleep infinity (保持运行)

    返回:
        创建的容器对象
    """
    pass
```

#### 2.3.4 容器重置
```python
def _reset_container(self, container: docker.Container) -> bool:
    """
    重置容器状态

    步骤:
    1. 清理 /tmp 目录 (docker exec rm -rf /tmp/*)
    2. 终止所有 Python 进程 (killall python)
    3. 清理环境变量 (恢复初始状态)
    4. 验证重置有效性

    返回:
        重置是否成功
    """
    pass
```

#### 2.3.5 健康检查
```python
def _health_check(self, container: docker.Container) -> bool:
    """
    检查容器健康状态

    检查项:
    1. 容器状态是否为 'running'
    2. 容器是否响应命令 (docker exec echo test)
    3. 内存使用是否正常 (< 90%)
    4. 容器进程数是否正常 (< 50)

    返回:
        是否健康
    """
    pass
```

---

## 3. 容器生命周期

### 3.1 生命周期状态图

```
┌─────────────────────────────────────────────────────────────┐
│                     容器池生命周期                              │
└─────────────────────────────────────────────────────────────┘

    [初始化]
       │
       ├─→ 创建 initial_size 个容器
       │
       ↓
  ┌──────────┐
  │ AVAILABLE│←──────────────────────┐
  │  (队列)   │                        │
  └──────────┘                        │
       │                              │
       │ get_container()              │ return_container()
       │                              │
       ↓                              │
  ┌──────────┐    执行代码        ┌──────────┐
  │  IN_USE  │─────────────→    │  RESET   │
  │          │                   │  (重置)   │
  └──────────┘                   └──────────┘
       │                              │
       │ 健康检查失败                  │ 重置成功
       │                              │
       ↓                              ↑
  ┌──────────┐                        │
  │ UNHEALTHY│                        │
  │  (销毁)   │                        │
  └──────────┘                        │
       │                              │
       │ 销毁并重建                    │
       │                              │
       └──────────────────────────────┘
```

### 3.2 容器状态转换

| 状态 | 说明 | 转换条件 |
|------|------|---------|
| AVAILABLE | 可用状态，在队列中等待 | 初始创建、重置成功 |
| IN_USE | 使用中，正在执行代码 | 被 get_container() 获取 |
| RESET | 重置中，清理状态 | return_container() 触发 |
| UNHEALTHY | 不健康，待销毁 | 健康检查失败、重置失败 |

---

## 4. 容器获取与归还流程

### 4.1 获取流程

```
┌────────────────────────────────────────────────────────────┐
│                   获取容器流程图                              │
└────────────────────────────────────────────────────────────┘

用户请求
   │
   ↓
[get_container(timeout=30)]
   │
   ├─→ 尝试从队列获取 (非阻塞)
   │
   ↓
  队列有容器?
   │
   ├─ YES ─→ 获取容器
   │         │
   │         ↓
   │      健康检查
   │         │
   │         ├─ PASS ─→ 标记 IN_USE → 返回容器 ✓
   │         │
   │         └─ FAIL ─→ 销毁容器 → 重试
   │
   └─ NO ──→ 池未满?
             │
             ├─ YES ─→ 创建新容器 → 返回容器 ✓
             │
             └─ NO ──→ 阻塞等待 (timeout)
                       │
                       ├─→ 有容器归还 → 获取容器 ✓
                       │
                       └─→ 超时 → 返回 None ✗
```

### 4.2 归还流程

```
┌────────────────────────────────────────────────────────────┐
│                   归还容器流程图                              │
└────────────────────────────────────────────────────────────┘

执行完成
   │
   ↓
[return_container(container)]
   │
   ├─→ 停止容器进程 (docker stop)
   │
   ↓
[重置容器]
   │
   ├─→ 清理 /tmp 目录
   ├─→ 终止 Python 进程
   ├─→ 清理环境变量
   │
   ↓
重置成功?
   │
   ├─ YES ─→ [健康检查]
   │         │
   │         ├─ PASS ─→ 放回队列 → 更新元数据 ✓
   │         │
   │         └─ FAIL ─→ 销毁容器 → 创建新容器 → 放回队列
   │
   └─ NO ──→ 销毁容器 → 创建新容器 → 放回队列
```

---

## 5. 容器重置策略

### 5.1 重置目标
确保容器状态完全干净，不影响下次代码执行:
- 无残留文件
- 无残留进程
- 无环境变量污染
- 无内存泄漏

### 5.2 重置步骤

```python
def _reset_container(self, container: docker.Container) -> bool:
    """容器重置详细步骤"""

    try:
        # 1. 终止所有用户进程 (保留主进程 sleep infinity)
        container.exec_run(
            "sh -c 'pkill -9 python || true'",
            detach=False
        )

        # 2. 清理临时目录
        container.exec_run(
            "sh -c 'rm -rf /tmp/* /tmp/.* 2>/dev/null || true'",
            detach=False
        )

        # 3. 清理环境变量 (重新设置为初始状态)
        # 注: 由于容器是只读的，环境变量污染风险较低

        # 4. 验证重置有效性
        result = container.exec_run("echo 'reset_test'")
        if result.exit_code != 0:
            return False

        # 5. 检查 /tmp 是否为空
        result = container.exec_run("ls -A /tmp")
        if result.output.strip():
            # /tmp 不为空，重置可能失败
            return False

        # 6. 检查进程数 (应该只有主进程)
        result = container.exec_run("ps aux | wc -l")
        process_count = int(result.output.strip())
        if process_count > 3:  # 标题行 + sleep + ps 命令
            return False

        return True

    except Exception as e:
        logger.error(f"Container reset failed: {e}")
        return False
```

### 5.3 重置验证

```python
def _verify_reset(self, container: docker.Container) -> bool:
    """验证重置是否成功"""

    checks = [
        # 检查1: 容器响应正常
        ("echo test", lambda r: r.exit_code == 0),

        # 检查2: /tmp 目录为空
        ("ls -A /tmp", lambda r: not r.output.strip()),

        # 检查3: Python 进程已清理
        ("pgrep python", lambda r: r.exit_code != 0),

        # 检查4: 进程数正常 (< 5)
        ("ps aux | wc -l", lambda r: int(r.output.strip()) < 5),
    ]

    for cmd, check_fn in checks:
        result = container.exec_run(cmd)
        if not check_fn(result):
            return False

    return True
```

---

## 6. 健康检查机制

### 6.1 检查策略

| 检查类型 | 频率 | 超时 | 失败阈值 |
|---------|------|------|---------|
| 定期检查 | 30秒 | 5秒 | 3次连续失败 |
| 使用前检查 | 每次获取 | 2秒 | 1次失败 |
| 归还后检查 | 每次归还 | 5秒 | 1次失败 |

### 6.2 健康检查项

```python
def _health_check(self, container: docker.Container) -> bool:
    """全面健康检查"""

    try:
        # 1. 检查容器状态
        container.reload()
        if container.status != 'running':
            logger.warning(f"Container {container.short_id} not running: {container.status}")
            return False

        # 2. 检查容器响应性 (echo 测试)
        result = container.exec_run(
            "echo health_check",
            timeout=2
        )
        if result.exit_code != 0:
            logger.warning(f"Container {container.short_id} not responsive")
            return False

        # 3. 检查内存使用
        stats = container.stats(stream=False)
        memory_usage = stats['memory_stats']['usage']
        memory_limit = stats['memory_stats']['limit']
        memory_percent = (memory_usage / memory_limit) * 100

        if memory_percent > 90:
            logger.warning(f"Container {container.short_id} high memory: {memory_percent:.1f}%")
            return False

        # 4. 检查进程数
        result = container.exec_run("ps aux | wc -l")
        process_count = int(result.output.strip())

        if process_count > 50:
            logger.warning(f"Container {container.short_id} too many processes: {process_count}")
            return False

        # 5. 检查文件系统 (只读保护是否完好)
        result = container.exec_run("touch /test_file 2>&1")
        if result.exit_code == 0:
            logger.error(f"Container {container.short_id} filesystem not read-only!")
            return False

        return True

    except Exception as e:
        logger.error(f"Health check failed: {e}")
        return False
```

### 6.3 后台健康检查线程

```python
def _background_health_check(self):
    """后台定期健康检查"""

    while self.running:
        time.sleep(self.health_check_interval)

        unhealthy_containers = []

        with self.lock:
            # 检查所有容器 (包括使用中和可用的)
            all_containers = list(self.container_metadata.keys())

        for container_id in all_containers:
            metadata = self.container_metadata.get(container_id)
            if not metadata:
                continue

            # 跳过正在使用的容器 (避免干扰执行)
            if metadata.status == 'in_use':
                continue

            # 执行健康检查
            is_healthy = self._health_check(metadata.container)

            if not is_healthy:
                metadata.health_check_failures += 1

                # 连续失败3次，标记为不健康
                if metadata.health_check_failures >= 3:
                    unhealthy_containers.append(container_id)
            else:
                metadata.health_check_failures = 0

        # 销毁不健康容器并重建
        for container_id in unhealthy_containers:
            self._destroy_and_replace_container(container_id)
```

---

## 7. 超时回收机制

### 7.1 回收策略

```python
def _background_idle_cleanup(self):
    """后台空闲容器回收线程"""

    while self.running:
        time.sleep(60)  # 每分钟检查一次

        current_time = time.time()
        containers_to_remove = []

        with self.lock:
            # 检查可用容器的空闲时间
            for container_id, metadata in self.container_metadata.items():
                if metadata.status != 'available':
                    continue

                idle_time = current_time - metadata.last_used_at

                # 超过空闲时间且超过最小池大小
                if idle_time > self.idle_timeout:
                    current_pool_size = self._get_pool_size()
                    if current_pool_size > self.min_size:
                        containers_to_remove.append(container_id)

        # 销毁空闲容器
        for container_id in containers_to_remove:
            self._destroy_container(container_id)
```

### 7.2 容器泄漏防护

```python
def _check_leaked_containers(self):
    """检查并清理泄漏的容器"""

    # 场景1: 程序崩溃后，容器未正确清理
    # 场景2: Docker daemon 重启后，容器状态不一致

    try:
        # 获取所有标记为此池的容器
        filters = {
            'label': f'helloagents.pool_id={self.pool_id}'
        }
        all_containers = self.client.containers.list(all=True, filters=filters)

        tracked_ids = set(self.container_metadata.keys())

        for container in all_containers:
            if container.id not in tracked_ids:
                # 发现未追踪的容器，清理
                logger.warning(f"Found leaked container: {container.short_id}")
                container.remove(force=True)

    except Exception as e:
        logger.error(f"Check leaked containers failed: {e}")
```

---

## 8. 并发控制

### 8.1 线程安全设计

```python
# 使用 Queue 实现天然的线程安全
from queue import Queue, Empty, Full

class ContainerPool:
    def __init__(self):
        # Queue 是线程安全的，支持并发 get/put
        self.available_containers = Queue(maxsize=self.max_size)

        # 使用 RLock 保护共享状态
        self.lock = threading.RLock()  # 可重入锁

        # 受保护的共享状态
        self.in_use_containers = {}
        self.container_metadata = {}
        self.stats = {}
```

### 8.2 获取容器的并发控制

```python
def get_container(self, timeout: int = 30) -> Optional[docker.Container]:
    """支持多线程并发获取"""

    start_time = time.time()

    while True:
        # 1. 尝试快速获取 (非阻塞)
        try:
            container = self.available_containers.get_nowait()

            # 健康检查
            if self._health_check(container):
                with self.lock:
                    self._mark_in_use(container)
                return container
            else:
                # 不健康，销毁并重试
                self._destroy_container(container.id)
                continue

        except Empty:
            # 队列为空
            pass

        # 2. 检查是否可以创建新容器
        with self.lock:
            current_size = len(self.container_metadata)

            if current_size < self.max_size:
                # 未达上限，创建新容器
                container = self._create_container()
                self._mark_in_use(container)
                return container

        # 3. 达到上限，阻塞等待
        elapsed = time.time() - start_time
        remaining_timeout = timeout - elapsed

        if remaining_timeout <= 0:
            logger.warning("Get container timeout")
            return None

        try:
            # 阻塞等待，最多 remaining_timeout 秒
            container = self.available_containers.get(timeout=remaining_timeout)

            if self._health_check(container):
                with self.lock:
                    self._mark_in_use(container)
                return container
            else:
                self._destroy_container(container.id)
                continue

        except Empty:
            logger.warning("Get container timeout")
            return None
```

### 8.3 归还容器的并发控制

```python
def return_container(self, container: docker.Container) -> None:
    """支持多线程并发归还"""

    container_id = container.id

    # 1. 标记为非使用状态
    with self.lock:
        if container_id in self.in_use_containers:
            del self.in_use_containers[container_id]

    # 2. 重置容器 (耗时操作，不持锁)
    reset_success = self._reset_container(container)

    if not reset_success:
        # 重置失败，销毁并重建
        self._destroy_and_replace_container(container_id)
        return

    # 3. 健康检查
    is_healthy = self._health_check(container)

    if not is_healthy:
        # 不健康，销毁并重建
        self._destroy_and_replace_container(container_id)
        return

    # 4. 归还到队列
    with self.lock:
        metadata = self.container_metadata.get(container_id)
        if metadata:
            metadata.status = 'available'
            metadata.last_used_at = time.time()
            metadata.reset_count += 1

    # 5. 放回队列 (Queue 是线程安全的)
    try:
        self.available_containers.put_nowait(container)
    except Full:
        # 队列已满 (不应该发生)，销毁容器
        logger.error("Queue full when returning container")
        self._destroy_container(container_id)
```

---

## 9. 性能优化方案

### 9.1 预热策略

```python
def _initialize_pool(self):
    """初始化容器池 (预热)"""

    logger.info(f"Initializing container pool with {self.initial_size} containers")

    # 并行创建容器 (使用线程池加速)
    with ThreadPoolExecutor(max_workers=self.initial_size) as executor:
        futures = [
            executor.submit(self._create_container)
            for _ in range(self.initial_size)
        ]

        for future in as_completed(futures):
            try:
                container = future.result()
                self.available_containers.put(container)
                logger.info(f"Container {container.short_id} ready")
            except Exception as e:
                logger.error(f"Failed to create container: {e}")

    # 启动后台线程
    self._start_background_threads()
```

### 9.2 懒加载策略

```python
def get_container(self, timeout: int = 30) -> Optional[docker.Container]:
    """懒加载: 需要时才创建容器"""

    # 只在需要时创建，避免启动时等待
    # (见 8.2 节的实现)
```

### 9.3 动态扩缩容

```python
def _auto_scale(self):
    """根据负载动态调整池大小"""

    with self.lock:
        available_count = self.available_containers.qsize()
        in_use_count = len(self.in_use_containers)
        total_count = len(self.container_metadata)

        # 扩容条件: 可用容器 < 2 且未达上限
        if available_count < 2 and total_count < self.max_size:
            create_count = min(2, self.max_size - total_count)
            logger.info(f"Auto-scaling: creating {create_count} containers")

            for _ in range(create_count):
                container = self._create_container()
                self.available_containers.put(container)

        # 缩容条件: 可用容器 > 5 且超过最小大小
        if available_count > 5 and total_count > self.min_size:
            remove_count = min(available_count - 3, total_count - self.min_size)
            logger.info(f"Auto-scaling: removing {remove_count} containers")

            for _ in range(remove_count):
                try:
                    container = self.available_containers.get_nowait()
                    self._destroy_container(container.id)
                except Empty:
                    break
```

### 9.4 容器复用优化

```python
# 策略1: 降低重置开销
# - 只清理必要的资源 (/tmp)
# - 避免重启容器 (重启耗时)
# - 使用 killall 而非逐个终止进程

# 策略2: 容器标签与追踪
# - 为容器添加标签，便于管理
# - 标签包含: pool_id, created_at, version

def _create_container(self) -> docker.Container:
    """创建带标签的容器"""

    container = self.client.containers.run(
        image=self.image,
        command=["sleep", "infinity"],
        detach=True,

        # 资源限制
        mem_limit="128m",
        cpu_quota=50000,
        pids_limit=64,

        # 安全配置
        network_disabled=True,
        read_only=True,
        cap_drop=['ALL'],

        # 临时目录
        tmpfs={'/tmp': 'size=10M,mode=1777'},

        # 标签 (用于追踪和管理)
        labels={
            'helloagents.pool_id': self.pool_id,
            'helloagents.created_at': str(time.time()),
            'helloagents.version': '1.0',
        },

        # 不自动删除 (由池管理)
        remove=False,
        auto_remove=False,
    )

    return container
```

---

## 10. 代码执行流程整合

### 10.1 整合 CodeSandbox

```python
class CodeSandbox:
    """沙箱类整合容器池"""

    def __init__(self, image: str = "python:3.11-slim", timeout: int = 30):
        self.image = image
        self.timeout = timeout

        # 使用容器池替代直接创建容器
        self.pool = ContainerPool(
            initial_size=3,
            max_size=10,
            image=image
        )

    def execute_python(self, code: str) -> Tuple[bool, str, float]:
        """执行 Python 代码 (使用容器池)"""

        # 安全检查
        is_safe, error_msg = self._check_code_safety(code)
        if not is_safe:
            return False, error_msg, 0.0

        # 从池获取容器
        container = self.pool.get_container(timeout=30)
        if not container:
            return False, "无法获取容器 (池已满或超时)", 0.0

        try:
            start_time = time.time()

            # 在容器中执行代码
            result = container.exec_run(
                ["python", "-c", code],
                demux=True,
                timeout=self.timeout
            )

            execution_time = time.time() - start_time

            # 处理输出
            stdout, stderr = result.output
            output = (stdout or b'').decode('utf-8')
            error = (stderr or b'').decode('utf-8')

            # 截断输出
            MAX_OUTPUT_SIZE = 10000
            if len(output) > MAX_OUTPUT_SIZE:
                output = output[:MAX_OUTPUT_SIZE] + f'\n... (截断)'

            if result.exit_code == 0:
                return True, output, execution_time
            else:
                return False, error or output, execution_time

        except Exception as e:
            return False, f"执行错误: {str(e)}", 0.0

        finally:
            # 归还容器到池
            self.pool.return_container(container)
```

### 10.2 执行流程对比

**旧流程 (一次性容器):**
```
用户请求 → 创建容器 (1-2s) → 执行代码 (0.1s) → 销毁容器 (0.5s) → 返回结果
总耗时: 1.6-2.6秒
```

**新流程 (容器池):**
```
用户请求 → 获取容器 (0.05s) → 执行代码 (0.1s) → 重置容器 (0.3s) → 归还容器 (0.05s) → 返回结果
总耗时: 0.5秒 (用户感知: 0.15秒，因为重置异步)
```

**性能提升: 3-5倍**

---

## 11. 监控与统计

### 11.1 统计指标

```python
def get_stats(self) -> dict:
    """获取池统计信息"""

    with self.lock:
        available_count = self.available_containers.qsize()
        in_use_count = len(self.in_use_containers)
        total_count = len(self.container_metadata)

        return {
            # 容器数量
            'available_containers': available_count,
            'in_use_containers': in_use_count,
            'total_containers': total_count,

            # 累计统计
            'total_created': self.stats['total_created'],
            'total_destroyed': self.stats['total_destroyed'],
            'total_executions': self.stats['total_executions'],
            'total_resets': self.stats['total_resets'],
            'health_check_failures': self.stats['health_check_failures'],

            # 容器详情
            'containers': [
                {
                    'id': m.container_id[:12],
                    'status': m.status,
                    'created_at': m.created_at,
                    'last_used_at': m.last_used_at,
                    'execution_count': m.execution_count,
                    'reset_count': m.reset_count,
                }
                for m in self.container_metadata.values()
            ]
        }
```

### 11.2 监控接口

```python
# 添加到 FastAPI 路由
@app.get("/api/sandbox/stats")
async def get_sandbox_stats():
    """获取沙箱统计信息"""
    return sandbox.pool.get_stats()

# 返回示例:
{
    "available_containers": 2,
    "in_use_containers": 1,
    "total_containers": 3,
    "total_created": 5,
    "total_destroyed": 2,
    "total_executions": 150,
    "total_resets": 147,
    "health_check_failures": 3,
    "containers": [
        {
            "id": "a1b2c3d4e5f6",
            "status": "available",
            "created_at": 1704700000.0,
            "last_used_at": 1704700300.0,
            "execution_count": 50,
            "reset_count": 49
        }
    ]
}
```

---

## 12. 错误处理与恢复

### 12.1 异常场景处理

| 场景 | 检测方法 | 恢复策略 |
|------|---------|---------|
| 容器创建失败 | 捕获 Docker API 异常 | 记录错误，跳过该容器 |
| 容器崩溃 | 健康检查失败 | 销毁并重建 |
| 重置失败 | 验证重置返回 False | 销毁并重建 |
| 执行超时 | exec_run timeout 参数 | 强制停止，重置容器 |
| Docker daemon 重启 | 连接失败 | 重新连接，重建池 |
| 池耗尽 (达到上限) | 队列为空且达到 max_size | 阻塞等待或返回错误 |
| 内存泄漏 | 健康检查监控内存 | 销毁并重建 |

### 12.2 优雅关闭

```python
def shutdown(self):
    """优雅关闭容器池"""

    logger.info("Shutting down container pool...")

    # 停止后台线程
    self.running = False

    if self.health_check_thread:
        self.health_check_thread.join(timeout=5)

    if self.idle_cleanup_thread:
        self.idle_cleanup_thread.join(timeout=5)

    # 等待使用中的容器归还 (最多30秒)
    deadline = time.time() + 30
    while self.in_use_containers and time.time() < deadline:
        logger.info(f"Waiting for {len(self.in_use_containers)} containers to return...")
        time.sleep(1)

    # 销毁所有容器
    with self.lock:
        all_containers = list(self.container_metadata.values())

    for metadata in all_containers:
        try:
            metadata.container.stop(timeout=5)
            metadata.container.remove(force=True)
            logger.info(f"Destroyed container {metadata.container.short_id}")
        except Exception as e:
            logger.error(f"Failed to destroy container: {e}")

    # 关闭 Docker 客户端
    self.client.close()

    logger.info("Container pool shutdown complete")
```

---

## 13. 安全考虑

### 13.1 容器隔离加强

```python
# 容器配置保持与原有沙箱一致的安全设置
container_config = {
    # 资源限制
    'mem_limit': '128m',
    'memswap_limit': '128m',
    'cpu_quota': 50000,
    'pids_limit': 64,

    # 安全配置
    'network_disabled': True,      # 禁用网络
    'read_only': True,             # 只读文件系统
    'cap_drop': ['ALL'],           # 移除所有权限
    'security_opt': ['no-new-privileges'],  # 禁止提权

    # 临时目录
    'tmpfs': {'/tmp': 'size=10M,mode=1777'},
}
```

### 13.2 代码注入防护

```python
# 保持原有的安全检查
def _check_code_safety(self, code: str) -> Tuple[bool, Optional[str]]:
    """检查代码安全性 (黑名单)"""

    dangerous_patterns = [
        ('os.system', '禁止使用 os.system'),
        ('subprocess.', '禁止使用 subprocess'),
        ('eval(', '禁止使用 eval'),
        ('exec(', '禁止使用 exec'),
        # ... 更多规则
    ]

    for pattern, message in dangerous_patterns:
        if pattern in code:
            return False, f'安全检查失败: {message}'

    return True, None
```

### 13.3 容器逃逸防护

```python
# 1. 使用最新的 Docker 版本
# 2. 启用 AppArmor/SELinux
# 3. 定期更新基础镜像
# 4. 限制 Docker API 访问权限
# 5. 监控容器行为异常
```

---

## 14. 风险与限制

### 14.1 已识别风险

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| 容器重置不彻底 | 高 | 中 | 增强验证，失败时销毁重建 |
| 容器泄漏 | 中 | 低 | 定期检查未追踪容器 |
| Docker daemon 不稳定 | 高 | 低 | 自动重连，健康检查 |
| 并发竞争条件 | 中 | 中 | 使用线程安全数据结构和锁 |
| 内存泄漏 | 中 | 中 | 健康检查监控，定期重建 |
| 池耗尽导致阻塞 | 中 | 中 | 设置获取超时，监控告警 |

### 14.2 系统限制

1. **最大并发限制**: 10个容器
   - 受 `max_size` 参数限制
   - 受主机资源限制 (内存、CPU)
   - 建议: 根据主机配置调整

2. **单容器资源限制**: 128MB 内存、50% CPU
   - 限制复杂计算任务
   - 建议: 为高级用户提供更大容器选项

3. **容器复用限制**: 无状态执行
   - 不支持多次执行间的状态保持
   - 每次执行都是全新环境
   - 建议: 对于需要状态的任务，使用独立容器

4. **重置开销**: 0.3-0.5秒
   - 虽然比创建快，但仍有开销
   - 建议: 异步归还，不影响用户体验

### 14.3 技术债务

1. **健康检查开销**: 定期检查消耗资源
   - 建议: 根据负载动态调整频率

2. **容器标签管理**: 需要维护标签一致性
   - 建议: 统一标签规范，版本管理

3. **监控数据持久化**: 当前仅内存统计
   - 建议: 集成 Prometheus/Grafana

---

## 15. 部署与运维

### 15.1 配置参数

```python
# 推荐配置 (开发环境)
pool_config_dev = {
    'initial_size': 2,
    'max_size': 5,
    'min_size': 1,
    'idle_timeout': 300,      # 5分钟
    'health_check_interval': 60,  # 1分钟
}

# 推荐配置 (生产环境)
pool_config_prod = {
    'initial_size': 5,
    'max_size': 20,
    'min_size': 3,
    'idle_timeout': 600,      # 10分钟
    'health_check_interval': 30,  # 30秒
}
```

### 15.2 环境要求

| 组件 | 最低版本 | 推荐版本 |
|------|---------|---------|
| Docker Engine | 20.10+ | 24.0+ |
| Python | 3.11+ | 3.11+ |
| docker-py | 7.0+ | 7.1+ |
| 主机内存 | 2GB | 4GB+ |
| 主机 CPU | 2核 | 4核+ |

### 15.3 运维检查清单

- [ ] Docker daemon 运行正常
- [ ] 基础镜像已拉取 (`python:3.11-slim`)
- [ ] 主机资源充足 (内存 > 2GB)
- [ ] 容器池配置合理 (根据负载)
- [ ] 监控接口可访问 (`/api/sandbox/stats`)
- [ ] 日志正常输出
- [ ] 健康检查通过

---

## 16. 测试计划

### 16.1 单元测试

```python
# 测试用例列表
test_cases = [
    'test_pool_initialization',          # 池初始化
    'test_get_container',                # 获取容器
    'test_return_container',             # 归还容器
    'test_container_reset',              # 容器重置
    'test_health_check',                 # 健康检查
    'test_concurrent_get',               # 并发获取
    'test_pool_exhaustion',              # 池耗尽
    'test_container_failure',            # 容器故障
    'test_auto_scaling',                 # 自动扩缩容
    'test_idle_cleanup',                 # 空闲清理
    'test_graceful_shutdown',            # 优雅关闭
]
```

### 16.2 集成测试

```python
# 端到端测试场景
integration_tests = [
    'test_execute_simple_code',          # 简单代码执行
    'test_execute_error_code',           # 错误代码处理
    'test_execute_timeout',              # 超时处理
    'test_concurrent_executions',        # 并发执行
    'test_container_reuse',              # 容器复用
    'test_high_load',                    # 高负载测试
]
```

### 16.3 性能测试

```python
# 性能基准测试
performance_tests = {
    'container_creation': 'measure_creation_time',
    'container_reset': 'measure_reset_time',
    'get_container': 'measure_get_time',
    'execute_code': 'measure_execution_time',
    'concurrent_10': 'measure_concurrent_10_executions',
    'sustained_load': 'measure_sustained_100_executions',
}

# 目标性能指标
performance_targets = {
    'container_creation': '< 1.5s',
    'container_reset': '< 0.5s',
    'get_container_cached': '< 0.1s',
    'execute_simple_code': '< 0.2s',
    'p95_latency': '< 0.5s',
    'p99_latency': '< 1.0s',
}
```

---

## 17. 后续优化方向

### 17.1 短期优化 (1-2周)

1. **容器预热优化**
   - 预加载常用 Python 包
   - 减少首次执行延迟

2. **监控仪表板**
   - 可视化池状态
   - 实时性能指标

3. **配置优化**
   - 根据实际负载调整参数
   - A/B 测试不同配置

### 17.2 中期优化 (1-2月)

1. **多语言支持**
   - 支持 JavaScript (Node.js)
   - 支持 Go
   - 为不同语言创建独立池

2. **智能调度**
   - 根据代码复杂度分配资源
   - 优先级队列

3. **分布式容器池**
   - 跨多台主机的容器池
   - 负载均衡

### 17.3 长期优化 (3-6月)

1. **Kubernetes 集成**
   - 使用 K8s Pod 替代 Docker 容器
   - 自动扩缩容 (HPA)

2. **WebAssembly 支持**
   - 更轻量的隔离方案
   - 更快的启动速度

3. **机器学习优化**
   - 预测负载模式
   - 智能预热

---

## 18. 架构图

### 18.1 容器池整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                      HelloAgents Container Pool                  │
│                          容器池架构图                               │
└─────────────────────────────────────────────────────────────────┘

                         ┌──────────────────┐
                         │   FastAPI App    │
                         │  (Web Server)    │
                         └────────┬─────────┘
                                  │
                                  ↓
                         ┌──────────────────┐
                         │   CodeSandbox    │
                         │  execute_python()│
                         └────────┬─────────┘
                                  │
                                  ↓
                    ┌─────────────────────────────┐
                    │      ContainerPool          │
                    │  (容器池管理器)               │
                    ├─────────────────────────────┤
                    │  - get_container()          │
                    │  - return_container()       │
                    │  - _reset_container()       │
                    │  - _health_check()          │
                    └─────────────┬───────────────┘
                                  │
                    ┌─────────────┴───────────────┐
                    │                             │
                    ↓                             ↓
          ┌──────────────────┐          ┌──────────────────┐
          │  Available Queue │          │   In-Use Set     │
          │   (可用容器队列)   │          │  (使用中容器集合)  │
          ├──────────────────┤          ├──────────────────┤
          │  Container 1     │          │  Container 4     │
          │  Container 2     │          │  Container 5     │
          │  Container 3     │          └──────────────────┘
          └──────────────────┘
                    │
                    ↓
          ┌──────────────────────────────────────┐
          │      Background Threads              │
          ├──────────────────────────────────────┤
          │  • Health Check (每30秒)             │
          │  • Idle Cleanup (每60秒)             │
          │  • Auto Scale (动态调整)              │
          └──────────────────────────────────────┘
                    │
                    ↓
          ┌──────────────────────────────────────┐
          │         Docker Daemon                │
          ├──────────────────────────────────────┤
          │  Container 1  [python:3.11-slim]     │
          │  Container 2  [python:3.11-slim]     │
          │  Container 3  [python:3.11-slim]     │
          │  ...                                 │
          └──────────────────────────────────────┘
```

### 18.2 容器获取流程图

```
用户请求执行代码
      │
      ↓
┌─────────────────┐
│ execute_python()│
└────────┬────────┘
         │
         ↓
┌─────────────────┐
│ 安全检查代码      │ ───→ 不安全 ───→ 返回错误
└────────┬────────┘
         │ 安全
         ↓
┌─────────────────────┐
│ pool.get_container()│
└────────┬────────────┘
         │
         ↓
    尝试从队列获取
         │
         ├───→ 队列有容器 ───→ 健康检查 ───→ PASS ───→ 返回容器
         │                                │
         │                                └─→ FAIL ───→ 销毁 ───→ 重试
         │
         └───→ 队列为空
                 │
                 ↓
            池未满?
                 │
                 ├─→ YES ─→ 创建新容器 ─→ 返回容器
                 │
                 └─→ NO ──→ 阻塞等待 (timeout) ─→ 获取成功 ─→ 返回容器
                                             │
                                             └─→ 超时 ─→ 返回 None
```

### 18.3 容器重置与归还流程图

```
执行完成
   │
   ↓
┌──────────────────────┐
│ pool.return_container│
└──────────┬───────────┘
           │
           ↓
   标记为非使用状态
           │
           ↓
┌──────────────────────┐
│  停止容器进程         │
│  (docker stop)       │
└──────────┬───────────┘
           │
           ↓
┌──────────────────────┐
│  _reset_container()  │
├──────────────────────┤
│ 1. killall python    │
│ 2. rm -rf /tmp/*     │
│ 3. 验证重置          │
└──────────┬───────────┘
           │
           ↓
       重置成功?
           │
           ├─→ YES ─→ 健康检查 ─→ PASS ─→ 放回队列 ✓
           │                    │
           │                    └─→ FAIL ─→ 销毁重建 ─→ 放回队列
           │
           └─→ NO ──→ 销毁重建 ─→ 放回队列
```

### 18.4 健康检查流程图

```
┌─────────────────────────────────────────────────────────┐
│              定期健康检查 (每30秒)                          │
└─────────────────────────────────────────────────────────┘

后台线程定时触发
      │
      ↓
遍历所有容器
      │
      ├─→ 跳过使用中容器
      │
      ↓
┌──────────────────┐
│  _health_check() │
├──────────────────┤
│ 1. 容器状态       │ ─→ not running ─→ 不健康
│ 2. 响应性测试     │ ─→ no response ─→ 不健康
│ 3. 内存使用       │ ─→ > 90%       ─→ 不健康
│ 4. 进程数         │ ─→ > 50        ─→ 不健康
│ 5. 文件系统检查   │ ─→ 可写         ─→ 不健康
└─────────┬────────┘
          │
          ↓
      所有检查通过 ─→ 健康 ✓
          │
          └─→ 任一检查失败 ─→ 不健康
                              │
                              ↓
                    连续失败次数 >= 3?
                              │
                              ├─→ YES ─→ 销毁容器
                              │         │
                              │         ↓
                              │    创建新容器
                              │         │
                              │         ↓
                              │    放回队列
                              │
                              └─→ NO ──→ 增加失败计数
```

### 18.5 系统交互序列图

```
User      FastAPI    Sandbox    ContainerPool    Docker
 │           │          │             │             │
 │  POST     │          │             │             │
 │ /execute  │          │             │             │
 ├──────────→│          │             │             │
 │           │          │             │             │
 │           │ execute  │             │             │
 │           ├─────────→│             │             │
 │           │          │             │             │
 │           │          │ get_container()           │
 │           │          ├────────────→│             │
 │           │          │             │             │
 │           │          │             │ (从队列获取)  │
 │           │          │             │             │
 │           │          │←────────────┤             │
 │           │          │  container  │             │
 │           │          │             │             │
 │           │          │  exec_run("python -c ...") │
 │           │          ├────────────────────────────→
 │           │          │             │             │
 │           │          │             │     (执行)   │
 │           │          │             │             │
 │           │          │←────────────────────────────
 │           │          │           output          │
 │           │          │             │             │
 │           │          │ return_container()        │
 │           │          ├────────────→│             │
 │           │          │             │             │
 │           │          │             │  (重置容器)   │
 │           │          │             │  (健康检查)   │
 │           │          │             │  (放回队列)   │
 │           │          │             │             │
 │           │          │←────────────┤             │
 │           │          │             │             │
 │           │←─────────┤             │             │
 │           │  result  │             │             │
 │           │          │             │             │
 │←──────────┤          │             │             │
 │  response │          │             │             │
 │           │          │             │             │
```

---

## 19. 实施路线图

### Phase 1: 核心功能 (Week 1)
- [ ] 实现 ContainerPool 类基础结构
- [ ] 实现容器创建与销毁
- [ ] 实现容器获取与归还
- [ ] 实现容器重置逻辑
- [ ] 单元测试覆盖

### Phase 2: 健康检查 (Week 2)
- [ ] 实现健康检查逻辑
- [ ] 实现后台健康检查线程
- [ ] 实现不健康容器恢复
- [ ] 集成测试

### Phase 3: 优化与监控 (Week 3)
- [ ] 实现空闲超时回收
- [ ] 实现动态扩缩容
- [ ] 实现统计接口
- [ ] 性能测试与优化

### Phase 4: 集成与部署 (Week 4)
- [ ] 集成到 CodeSandbox
- [ ] 端到端测试
- [ ] 文档完善
- [ ] 生产环境部署

---

## 20. 总结

### 20.1 核心优势
1. **性能提升显著**: 容器复用使执行延迟降低 10-20 倍
2. **资源利用率高**: 容器池减少频繁创建销毁开销
3. **并发能力强**: 支持最多 10 个并发执行
4. **可靠性高**: 健康检查和自动恢复保证可用性
5. **可扩展性好**: 动态扩缩容应对负载变化

### 20.2 关键设计决策
- **容器复用 vs 一次性**: 选择复用提升性能
- **同步 vs 异步归还**: 选择同步保证一致性
- **固定池大小 vs 动态**: 选择动态适应负载
- **健康检查频率**: 30秒平衡开销与及时性

### 20.3 成功指标
- [ ] 平均执行延迟 < 0.5秒
- [ ] P95 延迟 < 0.5秒
- [ ] P99 延迟 < 1.0秒
- [ ] 容器重置成功率 > 99%
- [ ] 健康检查成功率 > 95%
- [ ] 并发处理能力 10 QPS

---

## 附录

### A. 参考资料
- [Docker SDK for Python](https://docker-py.readthedocs.io/)
- [Docker Security Best Practices](https://docs.docker.com/engine/security/)
- [Python Threading Documentation](https://docs.python.org/3/library/threading.html)
- [Queue - Thread-safe queues](https://docs.python.org/3/library/queue.html)

### B. 代码示例仓库
- 完整实现参考: `backend/app/sandbox.py` (原版)
- 容器池实现: `backend/app/container_pool.py` (待实现)
- 单元测试: `backend/tests/test_container_pool.py` (待实现)

### C. 版本历史
- v1.0 (2026-01-08): 初始架构设计完成

---

**文档结束**

技术架构师签名: Technical Architect
日期: 2026-01-08
